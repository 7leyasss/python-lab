import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, precision_score, recall_score

iris = load_iris()
X = iris.data[:, :2]  # Берём только sepal length и sepal width (первые два признака)
y = iris.target       # Метки классов

mask = (y == 0) | (y == 1)
X = X[mask]
y = y[mask]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

models = {
    "KNN": KNeighborsClassifier(n_neighbors=3),
    "Decision Tree": DecisionTreeClassifier(max_depth=3),
    "Logistic Regression": LogisticRegression()
}

for name, model in models.items():
    model.fit(X_train, y_train)

metrics = {}
for name, model in models.items():
    y_pred = model.predict(X_test)
    metrics[name] = {
        "accuracy": accuracy_score(y_test, y_pred),
        "precision": precision_score(y_test, y_pred),
        "recall": recall_score(y_test, y_pred)
    }

for name, metric in metrics.items():
    print(f"{name}:")
    print(f"  Accuracy: {metric['accuracy']:.2f}")
    print(f"  Precision: {metric['precision']:.2f}")
    print(f"  Recall: {metric['recall']:.2f}")
    print()

def plot_decision_boundary(model, X, y, title):
    # Создаём сетку для отображения границ
    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01),
                         np.arange(y_min, y_max, 0.01))
    
    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    
    plt.contourf(xx, yy, Z, alpha=0.4, cmap='RdYlGn')
    
    plt.scatter(X_train[:, 0], X_train[:, 1], c=y_train, cmap='bwr', edgecolor='k', label='Train', s=50)
    
    y_pred = model.predict(X_test)
    correct = (y_pred == y_test)
    incorrect = ~correct
    
    plt.scatter(X_test[correct, 0], X_test[correct, 1], c='green', marker='o', edgecolor='k', label='Correct', s=70)
    plt.scatter(X_test[incorrect, 0], X_test[incorrect, 1], c='red', marker='x', label='Incorrect', s=70)
    
    plt.xlabel('Sepal length')
    plt.ylabel('Sepal width')
    plt.title(title)
    plt.legend()
    plt.show()

for name, model in models.items():
    plot_decision_boundary(model, X, y, f"{name} Classification")
