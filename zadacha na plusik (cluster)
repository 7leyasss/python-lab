import math
from math import sqrt

# Функции для вычисления прямой методом наименьших квадратов
def set_k(points):
    lst_x, lst_y = zip(*points)
    myltiply_sum = sum(a[0] * a[1] for a in points)
    sum_x = sum(lst_x)
    sum_y = sum(lst_y)
    square_x_sum = sum([x ** 2 for x in lst_x])
    return (len(lst_x) * myltiply_sum - sum_x * sum_y) / (len(points) * square_x_sum - sum_x ** 2)

def set_b(points, a):
    lst_x, lst_y = zip(*points)
    sum_x = sum(lst_x)
    sum_y = sum(lst_y)
    return (sum_y - a * sum_x) / len(points)

def set_bisector_k(a1, a2):
    grd1 = math.atan(a1)
    grad2 = math.atan(a2)
    grad_bisector = (grd1 + grad2) / 2
    return math.tan(grad_bisector)

def set_bisector_b(b1, b2):
    return (b1 + b2) / 2

# Ввод точек
points1 = [(1, 5), (2, 2), (4, 4), (2.5, 3)]
points2 = [(5, 1), (4, 0), (4, -2), (8, -3)]

# Вычисление параметров прямых
a1 = set_k(points1)
b1 = set_b(points1, a1)
a2 = set_k(points2)
b2 = set_b(points2, a2)

# Разделяющая прямая
a_bisector = set_bisector_k(a1, a2)
b_bisector = set_bisector_b(b1, b2)
print(f"Разделяющая прямая: y = {a_bisector:.3f}x + {b_bisector:.3f}")

# Метод k-ближайших соседей
k = int(input("Введите количество ближайших соседей k: "))

# Ввод новой точки
b = [float(x) for x in input("Введите координаты точки для классификации: ").split()]

# Вычисление расстояний до ближайших соседей
r = []
for p in points1:
    r.append([sqrt((b[0] - p[0])**2 + (b[1] - p[1])**2), 0])  # 0 для первой группы
for p in points2:
    r.append([sqrt((b[0] - p[0])**2 + (b[1] - p[1])**2), 1])  # 1 для второй группы

# Сортировка расстояний
r.sort()
r = r[:k]

# Классификация
cnt_o = sum(1 for x in r if x[1] == 0)
cnt_x = k - cnt_o

if cnt_o > cnt_x:
    print(f"Точка {b} относится к первой группе (нулевым точкам), ближайших: {cnt_o}")
else:
    print(f"Точка {b} относится ко второй группе (крестикам), ближайших: {cnt_x}")
