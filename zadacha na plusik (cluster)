import math
from math import sqrt

# Метод наименьших квадратов
def set_k(points):
    lst_x, lst_y = zip(*points)
    multiply_sum = sum(a[0] * a[1] for a in points)
    sum_x = sum(lst_x)
    sum_y = sum(lst_y)
    square_x_sum = sum([x ** 2 for x in lst_x])
    return (len(lst_x) * multiply_sum - sum_x * sum_y) / (len(points) * square_x_sum - sum_x ** 2)

def set_b(points, a):
    lst_x, lst_y = zip(*points)
    sum_x = sum(lst_x)
    sum_y = sum(lst_y)
    return (sum_y - a * sum_x) / len(points)

def classify_point_with_knn(points1, points2, b, k):
    distances = []
    
    # Вычисление расстояний до точек первого кластера
    for point in points1:
        dist = sqrt((b[0] - point[0]) ** 2 + (b[1] - point[1]) ** 2)
        distances.append((dist, 0))  # 0 для первого кластера

    # Вычисление расстояний до точек второго кластера
    for point in points2:
        dist = sqrt((b[0] - point[0]) ** 2 + (b[1] - point[1]) ** 2)
        distances.append((dist, 1))  # 1 для второго кластера

    # Сортировка расстояний
    distances.sort()

    # Оставляем только k ближайших точек
    nearest_neighbors = distances[:k]

    # Подсчёт голосов
    count_cluster1 = sum(1 for d in nearest_neighbors if d[1] == 0)
    count_cluster2 = sum(1 for d in nearest_neighbors if d[1] == 1)

    return 0 if count_cluster1 > count_cluster2 else 1

# Данные
points1 = [(1, 5), (2, 2), (4, 4), (2.5, 3)]
points2 = [(5, 1), (4, 0), (4, -2), (8, -3)]

# Найдём прямые для двух кластеров
a1 = set_k(points1)
b1 = set_b(points1, a1)
a2 = set_k(points2)
b2 = set_b(points2, a2)

print(f"Прямая для первого массива точек: y = {a1:.3f}x + {b1:.3f}")
print(f"Прямая для второго массива точек: y = {a2:.3f}x + {b2:.3f}")

# Метод k-ближайших соседей для классификации
k = 3
new_point = [3, 3]
cluster = classify_point_with_knn(points1, points2, new_point, k)

# Вывод результата
cluster_name = "первому кластеру" if cluster == 0 else "второму кластеру"
print(f"Точка {new_point} относится к {cluster_name}.")
